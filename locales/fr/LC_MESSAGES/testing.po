# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <victor.levieux@gmail.com>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.1.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-11-20 19:31-0800\n"
"PO-Revision-Date: 2021-07-11 01:21-0500\n"
"Last-Translator: Victor LEVIEUX <victor.levieux@gmail.com>\n"
"Language: fr\n"
"Language-Team: fr_FR <victor.levieux@gmail.com>\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../project/docs/testing.rst:2 86b5754bc9f94d18889791001c256f90
msgid "Testing Flask Applications"
msgstr "Tester les applications Flask"

#: ../../project/docs/testing.rst:4 d16cf6038e184a5facf0b86b391f2791
msgid ""
"Flask provides utilities for testing an application. This documentation "
"goes over techniques for working with different parts of the application "
"in tests."
msgstr ""

#: ../../project/docs/testing.rst:8 d68f12b54aec4a0db5fdc19caea45876
msgid "We will use the `pytest`_ framework to set up and run our tests."
msgstr ""

#: ../../project/docs/testing.rst:16 95fb6dc6dad1444cb9bda2f6ba7f1ae8
#, python-format
msgid ""
"The :doc:`tutorial </tutorial/index>` goes over how to write tests for "
"100% coverage of the sample Flaskr blog application. See :doc:`the "
"tutorial on tests </tutorial/tests>` for a detailed explanation of "
"specific tests for an application."
msgstr ""

#: ../../project/docs/testing.rst:23 d35fb0911048413c9bc60e779c6cc653
msgid "Identifying Tests"
msgstr ""

#: ../../project/docs/testing.rst:25 f8ed8445464046fa864d87555a144df2
msgid ""
"Tests are typically located in the ``tests`` folder. Tests are functions "
"that start with ``test_``, in Python modules that start with ``test_``. "
"Tests can also be further grouped in classes that start with ``Test``."
msgstr ""

#: ../../project/docs/testing.rst:29 4465387068224523a3431abe75457704
msgid ""
"It can be difficult to know what to test. Generally, try to test the code"
" that you write, not the code of libraries that you use, since they are "
"already tested. Try to extract complex behaviors as separate functions to"
" test individually."
msgstr ""

#: ../../project/docs/testing.rst:36 0918d8c127b74fb2a9204e510f30e55d
msgid "Fixtures"
msgstr ""

#: ../../project/docs/testing.rst:38 6f27f946ddb04fc49d16c9741ff0a33e
msgid ""
"Pytest *fixtures* allow writing pieces of code that are reusable across "
"tests. A simple fixture returns a value, but a fixture can also do setup,"
" yield a value, then do teardown. Fixtures for the application, test "
"client, and CLI runner are shown below, they can be placed in "
"``tests/conftest.py``."
msgstr ""

#: ../../project/docs/testing.rst:44 49343d23a749432bb163a81c8a22ab87
msgid ""
"If you're using an :doc:`application factory </patterns/appfactories>`, "
"define an ``app`` fixture to create and configure an app instance. You "
"can add code before and after the ``yield`` to set up and tear down other"
" resources, such as creating and clearing a database."
msgstr ""

#: ../../project/docs/testing.rst:50 f25e0b0465e14f7eb52ef2dec7855bfd
msgid ""
"If you're not using a factory, you already have an app object you can "
"import and configure directly. You can still use an ``app`` fixture to "
"set up and tear down resources."
msgstr ""

#: ../../project/docs/testing.rst:84 b21be58e440c4a1b8926b3b718f5113a
msgid "Sending Requests with the Test Client"
msgstr ""

#: ../../project/docs/testing.rst:86 899710c2413e45329678278788973270
msgid ""
"The test client makes requests to the application without running a live "
"server. Flask's client extends :doc:`Werkzeug's client <werkzeug:test>`, "
"see those docs for additional information."
msgstr ""

#: ../../project/docs/testing.rst:91 fb8af8b25e93474996ec3beb4a6f3dec
msgid ""
"The ``client`` has methods that match the common HTTP request methods, "
"such as ``client.get()`` and ``client.post()``. They take many arguments "
"for building the request; you can find the full documentation in "
":class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``, "
"``query_string``, ``headers``, and ``data`` or ``json``."
msgstr ""

#: ../../project/docs/testing.rst:97 448e5b7351644b519cc16a6817f72b9f
msgid ""
"To make a request, call the method the request should use with the path "
"to the route to test. A :class:`~werkzeug.test.TestResponse` is returned "
"to examine the response data. It has all the usual properties of a "
"response object. You'll usually look at ``response.data``, which is the "
"bytes returned by the view. If you want to use text, Werkzeug 2.1 "
"provides ``response.text``, or use ``response.get_data(as_text=True)``."
msgstr ""

#: ../../project/docs/testing.rst:111 3c403a351ce841b8b53fdf911c29d616
msgid ""
"Pass a dict ``query_string={\"key\": \"value\", ...}`` to set arguments "
"in the query string (after the ``?`` in the URL). Pass a dict "
"``headers={}`` to set request headers."
msgstr ""

#: ../../project/docs/testing.rst:115 ee7570fd5e074d9982589988b1515585
msgid ""
"To send a request body in a POST or PUT request, pass a value to "
"``data``. If raw bytes are passed, that exact body is used. Usually, "
"you'll pass a dict to set form data."
msgstr ""

#: ../../project/docs/testing.rst:121 2c254a61f55749f69e2303bf16cd47df
msgid "Form Data"
msgstr ""

#: ../../project/docs/testing.rst:123 20c9a1ea496d4cd7af87d4ec2597caf1
msgid ""
"To send form data, pass a dict to ``data``. The ``Content-Type`` header "
"will be set to ``multipart/form-data`` or ``application/x-www-form-"
"urlencoded`` automatically."
msgstr ""

#: ../../project/docs/testing.rst:127 eb74eb73c1174c12a2785a7239f0ef0a
msgid ""
"If a value is a file object opened for reading bytes (``\"rb\"`` mode), "
"it will be treated as an uploaded file. To change the detected filename "
"and content type, pass a ``(file, filename, content_type)`` tuple. File "
"objects will be closed after making the request, so they do not need to "
"use the usual ``with open() as f:`` pattern."
msgstr ""

#: ../../project/docs/testing.rst:133 ef662159a39b4979b5d1302061aa671a
msgid ""
"It can be useful to store files in a ``tests/resources`` folder, then use"
" ``pathlib.Path`` to get files relative to the current test file."
msgstr ""

#: ../../project/docs/testing.rst:153 cffbfd08318543da9f34480164869c24
msgid "JSON Data"
msgstr ""

#: ../../project/docs/testing.rst:155 476d3764dd5d43a286ff79ad2088f481
msgid ""
"To send JSON data, pass an object to ``json``. The ``Content-Type`` "
"header will be set to ``application/json`` automatically."
msgstr ""

#: ../../project/docs/testing.rst:158 3964c0314f2a4923bee58f6869f818a2
msgid ""
"Similarly, if the response contains JSON data, the ``response.json`` "
"attribute will contain the deserialized object."
msgstr ""

#: ../../project/docs/testing.rst:180 2bf449d71ae64ce084fa03af933bda79
msgid "Following Redirects"
msgstr ""

#: ../../project/docs/testing.rst:182 b16c8b1144484e2eb6a587528ce4602c
msgid ""
"By default, the client does not make additional requests if the response "
"is a redirect. By passing ``follow_redirects=True`` to a request method, "
"the client will continue to make requests until a non-redirect response "
"is returned."
msgstr ""

#: ../../project/docs/testing.rst:187 f9a11a2335b14d0db0d9b0d081250201
msgid ""
":attr:`TestResponse.history <werkzeug.test.TestResponse.history>` is a "
"tuple of the responses that led up to the final response. Each response "
"has a :attr:`~werkzeug.test.TestResponse.request` attribute which records"
" the request that produced that response."
msgstr ""

#: ../../project/docs/testing.rst:203 46509cacaae44c788d44dabc014c18c1
#, fuzzy
msgid "Accessing and Modifying the Session"
msgstr "Accéder et modifier les sessions"

#: ../../project/docs/testing.rst:205 b9ac7e3207404a4f9944fa322a27d861
msgid ""
"To access Flask's context variables, mainly :data:`~flask.session`, use "
"the client in a ``with`` statement. The app and request context will "
"remain active *after* making a request, until the ``with`` block ends."
msgstr ""

#: ../../project/docs/testing.rst:222 1032e66adc1e4cad8de6c3d00d01e3b7
msgid ""
"If you want to access or set a value in the session *before* making a "
"request, use the client's "
":meth:`~flask.testing.FlaskClient.session_transaction` method in a "
"``with`` statement. It returns a session object, and will save the "
"session once the block ends."
msgstr ""

#: ../../project/docs/testing.rst:246 d61057de66574b9088bac890f311d0f6
msgid "Running Commands with the CLI Runner"
msgstr ""

#: ../../project/docs/testing.rst:248 49e3d46289644b8cac37abcde08f52b5
#, fuzzy
msgid ""
"Flask provides :meth:`~flask.Flask.test_cli_runner` to create a "
":class:`~flask.testing.FlaskCliRunner`, which runs CLI commands in "
"isolation and captures the output in a :class:`~click.testing.Result` "
"object. Flask's runner extends :doc:`Click's runner <click:testing>`, see"
" those docs for additional information."
msgstr ""
"Click est fourni avec des `utilitaires pour tester`_ vos commandes CLI. "
"Un :class:`~click.testing.CliRunner` exécute les commandes de manière "
"isolée et capture la sortie dans un objet :class:`~click.testing.Result`."

#: ../../project/docs/testing.rst:254 3421b4270a9b4e6181e1ef3ee42d98c0
#, fuzzy
msgid ""
"Use the runner's :meth:`~flask.testing.FlaskCliRunner.invoke` method to "
"call commands in the same way they would be called with the ``flask`` "
"command from the command line."
msgstr ""
"Flask fournit :meth:`~flask.Flask.test_cli_runner` pour créer une "
":class:`~flask.testing.FlaskCliRunner` qui passe l'application Flask à la"
" CLI automatiquement. Utilisez sa méthode "
":meth:`~flask.testing.FlaskCliRunner.invoke` pour appeler les commandes "
"de la même manière qu'elles seraient appelées depuis la ligne de "
"commande. ::"

#: ../../project/docs/testing.rst:276 553107178d0349aab51ceb54b07b3322
msgid "Tests that depend on an Active Context"
msgstr ""

#: ../../project/docs/testing.rst:278 6b9510a2a79c46b1a8265cf89a31ce4b
msgid ""
"You may have functions that are called from views or commands, that "
"expect an active :doc:`application context </appcontext>` or "
":doc:`request context  </reqcontext>` because they access ``request``, "
"``session``, or ``current_app``. Rather than testing them by making a "
"request or invoking the command, you can create and activate a context "
"directly."
msgstr ""

#: ../../project/docs/testing.rst:285 b7d1bd7954c4493da2444dbaf73b4a2d
msgid ""
"Use ``with app.app_context()`` to push an application context. For "
"example, database extensions usually require an active app context to "
"make queries."
msgstr ""

#: ../../project/docs/testing.rst:295 4ec7c592d0ae4e119d712b6918501e78
msgid ""
"Use ``with app.test_request_context()`` to push a request context. It "
"takes the same arguments as the test client's request methods."
msgstr ""

#: ../../project/docs/testing.rst:309 8865ef897e76420aa44ed151645058a3
msgid ""
"Creating a test request context doesn't run any of the Flask dispatching "
"code, so ``before_request`` functions are not called. If you need to call"
" these, usually it's better to make a full request instead. However, it's"
" possible to call them manually."
msgstr ""

#~ msgid "**Something that is untested is broken.**"
#~ msgstr "**Quelque chose qui n'est pas testé est cassé.**"

#~ msgid ""
#~ "The origin of this quote is "
#~ "unknown and while it is not "
#~ "entirely correct, it is also not "
#~ "far from the truth.  Untested "
#~ "applications make it hard to improve "
#~ "existing code and developers of untested"
#~ " applications tend to become pretty "
#~ "paranoid.  If an application has "
#~ "automated tests, you can safely make "
#~ "changes and instantly know if anything"
#~ " breaks."
#~ msgstr ""
#~ "L'origine de cette citation est inconnue"
#~ " et, bien qu'elle ne soit pas "
#~ "tout à fait correcte, elle n'est "
#~ "pas loin de la vérité.  Les "
#~ "applications non testées rendent difficile "
#~ "l'amélioration du code existant et les"
#~ " développeurs d'applications non testées "
#~ "ont tendance à devenir assez "
#~ "paranoïaques.  Si une application dispose "
#~ "de tests automatisés, vous pouvez "
#~ "apporter des modifications en toute "
#~ "sécurité et savoir instantanément si "
#~ "quelque chose se casse."

#~ msgid ""
#~ "Flask provides a way to test your"
#~ " application by exposing the Werkzeug "
#~ "test :class:`~werkzeug.test.Client` and handling "
#~ "the context locals for you. You "
#~ "can then use that with your "
#~ "favourite testing solution."
#~ msgstr ""
#~ "Flask fournit un moyen de tester "
#~ "votre application en exposant le "
#~ "Werkzeug :class:`~werkzeug.test.Client` de test "
#~ "et en gérant les contextes locaux "
#~ "pour vous. Vous pouvez ensuite "
#~ "l'utiliser avec votre solution de test"
#~ " préférée."

#~ msgid ""
#~ "In this documentation we will use "
#~ "the `pytest`_ package as the base "
#~ "framework for our tests. You can "
#~ "install it with ``pip``, like so::"
#~ msgstr ""
#~ "Dans cette documentation, nous utiliserons "
#~ "le paquet `pytest`_ comme infrastructure "
#~ "logicielle de base pour nos tests. "
#~ "Vous pouvez l'installer avec ``pip``, "
#~ "comme ceci :"

#~ msgid "The Application"
#~ msgstr "L'application"

#~ msgid ""
#~ "First, we need an application to "
#~ "test; we will use the application "
#~ "from the :doc:`tutorial/index`. If you "
#~ "don't have that application yet, get "
#~ "the source code from :gh:`the examples"
#~ " <examples/tutorial>`."
#~ msgstr ""
#~ "Tout d'abord, nous avons besoin d'une"
#~ " application à tester ; nous "
#~ "utiliserons l'application du :doc:`tutorial/index`."
#~ " Si vous n'avez pas encore cette "
#~ "application, récupérez le code source "
#~ "depuis :gh:`ces exemples <examples/tutorial>`."

#~ msgid ""
#~ "So that we can import the module"
#~ " ``flaskr`` correctly, we need to run"
#~ " ``pip install -e .`` in the "
#~ "folder ``tutorial``."
#~ msgstr ""
#~ "Pour que nous puissions importer "
#~ "correctement le module ``flaskr``, nous "
#~ "devons exécuter ``pip install -e .`` "
#~ "dans le dossier ``tutorial``."

#~ msgid "The Testing Skeleton"
#~ msgstr "Le squelette des tests"

#~ msgid ""
#~ "We begin by adding a tests "
#~ "directory under the application root.  "
#~ "Then create a Python file to store"
#~ " our tests (:file:`test_flaskr.py`). When "
#~ "we format the filename like "
#~ "``test_*.py``, it will be auto-"
#~ "discoverable by pytest."
#~ msgstr ""
#~ "Nous commençons par ajouter un "
#~ "répertoire tests sous la racine de "
#~ "l'application.  Ensuite, nous créons un "
#~ "fichier Python pour stocker nos tests"
#~ " (:file:`test_flaskr.py`). Si nous formatons "
#~ "le nom du fichier comme ``test_*.py``,"
#~ " il sera auto-découvrable par pytest."

#~ msgid ""
#~ "Next, we create a `pytest fixture`_ "
#~ "called :func:`client` that configures the "
#~ "application for testing and initializes "
#~ "a new database::"
#~ msgstr ""
#~ "Ensuite, nous créons un `pytest "
#~ "fixture`_ appelé :func:`client` qui configure"
#~ " l'application pour les tests et "
#~ "initialise une nouvelle base de données"
#~ " :"

#~ msgid ""
#~ "This client fixture will be called "
#~ "by each individual test.  It gives "
#~ "us a simple interface to the "
#~ "application, where we can trigger test"
#~ " requests to the application.  The "
#~ "client will also keep track of "
#~ "cookies for us."
#~ msgstr ""
#~ "Cette *fixture* client sera appelée par"
#~ " chaque test individuel.  Il nous "
#~ "donne une interface simple avec "
#~ "l'application, où nous pouvons déclencher "
#~ "des requêtes de test vers l'application."
#~ "  Le client gardera également la "
#~ "trace des cookies pour nous."

#~ msgid ""
#~ "During setup, the ``TESTING`` config "
#~ "flag is activated.  What this does "
#~ "is disable error catching during request"
#~ " handling, so that you get better "
#~ "error reports when performing test "
#~ "requests against the application."
#~ msgstr ""
#~ "Lors de l'installation, le *flag* de "
#~ "configuration ``TESTING`` est activé.  Ceci"
#~ " a pour effet de désactiver la "
#~ "capture des erreurs pendant le "
#~ "traitement des requêtes, de sorte que"
#~ " vous obtenez de meilleurs rapports "
#~ "d'erreurs lorsque vous effectuez des "
#~ "requêtes de test contre l'application."

#~ msgid ""
#~ "Because SQLite3 is filesystem-based, we"
#~ " can easily use the :mod:`tempfile` "
#~ "module to create a temporary database"
#~ " and initialize it. The "
#~ ":func:`~tempfile.mkstemp` function does two "
#~ "things for us: it returns a "
#~ "low-level file handle and a random"
#~ " file name, the latter we use "
#~ "as database name.  We just have to"
#~ " keep the `db_fd` around so that "
#~ "we can use the :func:`os.close` function"
#~ " to close the file."
#~ msgstr ""
#~ "Parce que SQLite3 est basé sur le"
#~ " système de fichiers, nous pouvons "
#~ "facilement utiliser le module :mod:`tempfile`"
#~ " pour créer une base de données "
#~ "temporaire et l'initialiser. La fonction "
#~ ":func:`~tempfile.mkstemp` fait deux choses "
#~ "pour nous : elle retourne un "
#~ "gestionnaire de fichier de bas niveau"
#~ " et un nom de fichier aléatoire, "
#~ "ce dernier étant utilisé comme nom "
#~ "de base de données.  Nous devons "
#~ "juste garder le `db_fd` pour pouvoir "
#~ "utiliser la fonction :func:`os.close` pour "
#~ "fermer le fichier."

#~ msgid ""
#~ "To delete the database after the "
#~ "test, the fixture closes the file "
#~ "and removes it from the filesystem."
#~ msgstr ""
#~ "Pour supprimer la base de données "
#~ "après le test, le dispositif ferme "
#~ "le fichier et le supprime du "
#~ "système de fichiers."

#~ msgid "If we now run the test suite, we should see the following output::"
#~ msgstr ""
#~ "Si nous exécutons maintenant la suite"
#~ " de tests, nous devrions voir la "
#~ "sortie suivante :"

#~ msgid ""
#~ "Even though it did not run any "
#~ "actual tests, we already know that "
#~ "our ``flaskr`` application is syntactically"
#~ " valid, otherwise the import would "
#~ "have died with an exception."
#~ msgstr ""
#~ "Même s'il n'a pas exécuté de réels"
#~ " tests, nous savons déjà que notre"
#~ " application ``flaskr`` est syntaxiquement "
#~ "valide, sinon l'importation aurait échoué "
#~ "avec une exception."

#~ msgid "The First Test"
#~ msgstr "Le premier test"

#~ msgid ""
#~ "Now it's time to start testing the"
#~ " functionality of the application. Let's"
#~ " check that the application shows "
#~ "\"No entries here so far\" if we"
#~ " access the root of the application"
#~ " (``/``).  To do this, we add a"
#~ " new test function to "
#~ ":file:`test_flaskr.py`, like this::"
#~ msgstr ""
#~ "Il est maintenant temps de commencer "
#~ "à tester la fonctionnalité de "
#~ "l'application. Vérifions que l'application "
#~ "affiche \"No entries here so far\" "
#~ "si nous accédons à la racine de"
#~ " l'application (``/``).  Pour ce faire, "
#~ "nous ajoutons une nouvelle fonction de"
#~ " test au fichier :file:`test_flaskr.py`, "
#~ "comme ceci :"

#~ msgid ""
#~ "Notice that our test functions begin "
#~ "with the word `test`; this allows "
#~ "`pytest`_ to automatically identify the "
#~ "function as a test to run."
#~ msgstr ""
#~ "Remarquez que nos fonctions de test "
#~ "commencent par le mot `test` ; "
#~ "cela permet à `pytest`_ d'identifier "
#~ "automatiquement la fonction comme un "
#~ "test à exécuter."

#~ msgid ""
#~ "By using ``client.get`` we can send "
#~ "an HTTP ``GET`` request to the "
#~ "application with the given path.  The"
#~ " return value will be a "
#~ ":class:`~flask.Flask.response_class` object. We can"
#~ " now use the "
#~ ":attr:`~werkzeug.wrappers.Response.data` attribute to "
#~ "inspect the return value (as string) "
#~ "from the application. In this case, "
#~ "we ensure that ``'No entries here "
#~ "so far'`` is part of the output."
#~ msgstr ""
#~ "En utilisant ``client.get``, nous pouvons "
#~ "envoyer une requête HTTP ``GET`` à "
#~ "l'application avec le chemin donné.  La"
#~ " valeur de retour sera un objet "
#~ ":class:`~flask.Flask.response_class`. Nous pouvons "
#~ "maintenant utiliser l'attribut "
#~ ":attr:`~werkzeug.wrappers.Response.data` pour inspecter"
#~ " la valeur de retour (sous forme "
#~ "de chaîne) de l'application. Dans ce "
#~ "cas, nous nous assurons que ``'No "
#~ "entries here so far'`` fait partie "
#~ "de la sortie."

#~ msgid "Run it again and you should see one passing test::"
#~ msgstr "Exécutez-le à nouveau et vous devriez voir un test réussi :"

#~ msgid "Logging In and Out"
#~ msgstr "Connexion et déconnexion"

#~ msgid ""
#~ "The majority of the functionality of "
#~ "our application is only available for"
#~ " the administrative user, so we need"
#~ " a way to log our test client"
#~ " in and out of the application.  "
#~ "To do this, we fire some requests"
#~ " to the login and logout pages "
#~ "with the required form data (username"
#~ " and password).  And because the "
#~ "login and logout pages redirect, we "
#~ "tell the client to `follow_redirects`."
#~ msgstr ""
#~ "La majorité des fonctionnalités de notre"
#~ " application n'est disponible que pour "
#~ "l'utilisateur administratif. Nous devons donc"
#~ " trouver un moyen de connecter et "
#~ "déconnecter notre client de test de "
#~ "l'application.  Pour ce faire, nous "
#~ "envoyons des requêtes aux pages de "
#~ "connexion et de déconnexion avec les "
#~ "données de formulaire requises (nom "
#~ "d'utilisateur et mot de passe).  Et "
#~ "parce que les pages de connexion "
#~ "et de déconnexion redirigent, nous "
#~ "disons au client de suivre les "
#~ "redirections."

#~ msgid "Add the following two functions to your :file:`test_flaskr.py` file::"
#~ msgstr ""
#~ "Ajoutez les deux fonctions suivantes à"
#~ " votre fichier :file:`test_flaskr.py`:"

#~ msgid ""
#~ "Now we can easily test that "
#~ "logging in and out works and that"
#~ " it fails with invalid credentials.  "
#~ "Add this new test function::"
#~ msgstr ""
#~ "Maintenant, nous pouvons facilement tester "
#~ "que la connexion et la déconnexion "
#~ "fonctionnent et qu'elles échouent si les"
#~ " informations d'identification ne sont pas"
#~ " valides.  Ajoutez cette nouvelle fonction"
#~ " de test :"

#~ msgid "Test Adding Messages"
#~ msgstr "Test d'ajout de messages"

#~ msgid ""
#~ "We should also test that adding "
#~ "messages works.  Add a new test "
#~ "function like this::"
#~ msgstr ""
#~ "Nous devons également tester que l'ajout"
#~ " de messages fonctionne.  Ajoutez une "
#~ "nouvelle fonction de test comme ceci "
#~ ":"

#~ msgid ""
#~ "Here we check that HTML is allowed"
#~ " in the text but not in the "
#~ "title, which is the intended behavior."
#~ msgstr ""
#~ "Ici, nous vérifions que le HTML "
#~ "est autorisé dans le texte mais "
#~ "pas dans le titre, ce qui est "
#~ "le comportement souhaité."

#~ msgid "Running that should now give us three passing tests::"
#~ msgstr ""
#~ "L'exécution de ce test devrait "
#~ "maintenant nous donner trois tests "
#~ "réussis :"

#~ msgid "Other Testing Tricks"
#~ msgstr "Autres astuces de test"

#~ msgid ""
#~ "Besides using the test client as "
#~ "shown above, there is also the "
#~ ":meth:`~flask.Flask.test_request_context` method that "
#~ "can be used in combination with "
#~ "the ``with`` statement to activate a "
#~ "request context temporarily.  With this "
#~ "you can access the :class:`~flask.request`,"
#~ " :class:`~flask.g` and :class:`~flask.session` "
#~ "objects like in view functions.  Here"
#~ " is a full example that demonstrates"
#~ " this approach::"
#~ msgstr ""
#~ "Outre l'utilisation du client de test"
#~ " comme indiqué ci-dessus, il existe"
#~ " également la méthode "
#~ ":meth:`~flask.Flask.test_request_context` qui peut "
#~ "être utilisée en combinaison avec "
#~ "l'instruction ``with`` pour activer "
#~ "temporairement un contexte de requête.  "
#~ "Avec cette méthode, vous pouvez accéder"
#~ " aux objets :class:`~flask.request`, "
#~ ":class:`~flask.g` et :class:`~flask.session` comme"
#~ " dans les fonctions de vue.  Voici"
#~ " un exemple complet qui démontre "
#~ "cette approche :"

#~ msgid ""
#~ "All the other objects that are "
#~ "context bound can be used in the"
#~ " same way."
#~ msgstr ""
#~ "Tous les autres objets liés au "
#~ "contexte peuvent être utilisés de la "
#~ "même manière."

#~ msgid ""
#~ "If you want to test your "
#~ "application with different configurations and"
#~ " there does not seem to be a"
#~ " good way to do that, consider "
#~ "switching to application factories (see "
#~ ":doc:`patterns/appfactories`)."
#~ msgstr ""
#~ "Si vous voulez tester votre application"
#~ " avec différentes configurations et qu'il"
#~ " ne semble pas y avoir de bon"
#~ " moyen de le faire, envisagez de "
#~ "passer aux fabriques d'applications (voir "
#~ ":doc:`patterns/appfactories`)."

#~ msgid ""
#~ "Note however that if you are using"
#~ " a test request context, the "
#~ ":meth:`~flask.Flask.before_request` and "
#~ ":meth:`~flask.Flask.after_request` functions are not"
#~ " called automatically.  However "
#~ ":meth:`~flask.Flask.teardown_request` functions are "
#~ "indeed executed when the test request"
#~ " context leaves the ``with`` block.  "
#~ "If you do want the "
#~ ":meth:`~flask.Flask.before_request` functions to be"
#~ " called as well, you need to "
#~ "call :meth:`~flask.Flask.preprocess_request` yourself::"
#~ msgstr ""
#~ "Notez cependant que si vous utilisez "
#~ "un contexte de requête de test, "
#~ "les fonctions :meth:`~flask.Flask.before_request` et"
#~ " :meth:`~flask.Flask.after_request` ne sont pas"
#~ " appelées automatiquement.  Cependant, les "
#~ "fonctions :meth:`~flask.Flask.teardown_request` sont "
#~ "effectivement exécutées lorsque le contexte"
#~ " de la requête de test quitte "
#~ "le bloc ``with``.  Si vous souhaitez "
#~ "que les fonctions "
#~ ":meth:`~flask.Flask.before_request` soient également "
#~ "appelées, vous devez appeler vous-même"
#~ " :meth:`~flask.Flask.preprocess_request`:"

#~ msgid ""
#~ "This can be necessary to open "
#~ "database connections or something similar "
#~ "depending on how your application was"
#~ " designed."
#~ msgstr ""
#~ "Cela peut être nécessaire pour ouvrir"
#~ " des connexions à des bases de "
#~ "données ou quelque chose de similaire,"
#~ " selon la façon dont votre "
#~ "application a été conçue."

#~ msgid ""
#~ "If you want to call the "
#~ ":meth:`~flask.Flask.after_request` functions you "
#~ "need to call into "
#~ ":meth:`~flask.Flask.process_response` which however "
#~ "requires that you pass it a "
#~ "response object::"
#~ msgstr ""
#~ "Si vous voulez appeler les fonctions "
#~ ":meth:`~flask.Flask.after_request`, vous devez faire"
#~ " appel à :meth:`~flask.Flask.process_response` "
#~ "qui nécessite toutefois que vous lui "
#~ "passiez un objet de réponse :"

#~ msgid ""
#~ "This in general is less useful "
#~ "because at that point you can "
#~ "directly start using the test client."
#~ msgstr ""
#~ "Ceci est en général moins utile "
#~ "car à ce moment-là, vous pouvez "
#~ "directement commencer à utiliser le "
#~ "client de test."

#~ msgid "Faking Resources and Context"
#~ msgstr "Contournement des ressources et du contexte"

#~ msgid ""
#~ "A very common pattern is to store"
#~ " user authorization information and "
#~ "database connections on the application "
#~ "context or the :attr:`flask.g` object.  "
#~ "The general pattern for this is to"
#~ " put the object on there on "
#~ "first usage and then to remove it"
#~ " on a teardown.  Imagine for instance"
#~ " this code to get the current "
#~ "user::"
#~ msgstr ""
#~ "Un modèle très courant consiste à "
#~ "stocker les informations d'autorisation des"
#~ " utilisateurs et les connexions aux "
#~ "bases de données dans le contexte "
#~ "de l'application ou dans l'objet "
#~ ":attr:`flask.g`.  Le modèle général pour "
#~ "cela est de mettre l'objet à cet"
#~ " endroit lors de la première "
#~ "utilisation et de le supprimer lors "
#~ "du démontage.  Imaginez par exemple ce"
#~ " code pour obtenir l'utilisateur actuel "
#~ ":"

#~ msgid ""
#~ "For a test it would be nice "
#~ "to override this user from the "
#~ "outside without having to change some"
#~ " code.  This can be accomplished with"
#~ " hooking the :data:`flask.appcontext_pushed` "
#~ "signal::"
#~ msgstr ""
#~ "Pour un test, il serait bien de"
#~ " pouvoir remplacer cet utilisateur de "
#~ "l'extérieur sans avoir à modifier le "
#~ "code.  Ceci peut être accompli en "
#~ "accrochant le signal :data:`flask.appcontext_pushed`"
#~ " :"

#~ msgid "And then to use it::"
#~ msgstr "Et puis pour l'utiliser :"

#~ msgid "Keeping the Context Around"
#~ msgstr "Maintenir le contexte"

#~ msgid ""
#~ "Sometimes it is helpful to trigger "
#~ "a regular request but still keep "
#~ "the context around for a little "
#~ "longer so that additional introspection "
#~ "can happen.  With Flask 0.4 this "
#~ "is possible by using the "
#~ ":meth:`~flask.Flask.test_client` with a ``with`` "
#~ "block::"
#~ msgstr ""
#~ "Parfois, il est utile de déclencher "
#~ "une requête régulière mais de conserver"
#~ " le contexte un peu plus longtemps"
#~ " afin de permettre une introspection "
#~ "supplémentaire.  Avec Flask 0.4, cela "
#~ "est possible en utilisant le "
#~ ":meth:`~flask.Flask.test_client` avec un bloc "
#~ "``with`` :"

#~ msgid ""
#~ "If you were to use just the "
#~ ":meth:`~flask.Flask.test_client` without the "
#~ "``with`` block, the ``assert`` would "
#~ "fail with an error because `request` "
#~ "is no longer available (because you "
#~ "are trying to use it outside of"
#~ " the actual request)."
#~ msgstr ""
#~ "Si vous utilisiez seulement le "
#~ ":meth:`~flask.Flask.test_client` sans le bloc "
#~ "`with`, le ``assert`` échouerait avec "
#~ "une erreur car `request` n'est plus "
#~ "disponible (parce que vous essayez de"
#~ " l'utiliser en dehors de la requête"
#~ " actuelle)."

#~ msgid ""
#~ "Sometimes it can be very helpful "
#~ "to access or modify the sessions "
#~ "from the test client.  Generally there"
#~ " are two ways for this.  If you"
#~ " just want to ensure that a "
#~ "session has certain keys set to "
#~ "certain values you can just keep "
#~ "the context around and access "
#~ ":data:`flask.session`::"
#~ msgstr ""
#~ "Parfois, il peut être très utile "
#~ "d'accéder ou de modifier les sessions"
#~ " à partir du client de test.  "
#~ "Il y a généralement deux façons de"
#~ " procéder.  Si vous voulez simplement "
#~ "vous assurer que certaines clés d'une"
#~ " session ont certaines valeurs, vous "
#~ "pouvez conserver le contexte et accéder"
#~ " à :data:`flask.session` :"

#~ msgid ""
#~ "This however does not make it "
#~ "possible to also modify the session "
#~ "or to access the session before a"
#~ " request was fired.  Starting with "
#~ "Flask 0.8 we provide a so called"
#~ " “session transaction” which simulates the"
#~ " appropriate calls to open a session"
#~ " in the context of the test "
#~ "client and to modify it. At the"
#~ " end of the transaction the session"
#~ " is stored and ready to be used"
#~ " by the test client. This works "
#~ "independently of the session backend "
#~ "used::"
#~ msgstr ""
#~ "Cependant, cela ne permet pas de "
#~ "modifier la session ou d'accéder à "
#~ "la session avant qu'une requête ne "
#~ "soit lancée.  À partir de Flask "
#~ "0.8, nous fournissons une \"transaction "
#~ "de session\" qui simule les appels "
#~ "appropriés pour ouvrir une session dans"
#~ " le contexte du client de test "
#~ "et pour la modifier. A la fin "
#~ "de la transaction, la session est "
#~ "stockée et prête à être utilisée "
#~ "par le client de test. Ceci "
#~ "fonctionne indépendamment du backend de "
#~ "session utilisé :"

#~ msgid ""
#~ "Note that in this case you have"
#~ " to use the ``sess`` object instead"
#~ " of the :data:`flask.session` proxy.  The"
#~ " object however itself will provide "
#~ "the same interface."
#~ msgstr ""
#~ "Notez que dans ce cas, vous devez"
#~ " utiliser l'objet ``sess`` au lieu du"
#~ " proxy :data:`flask.session`.  Cependant, l'objet"
#~ " lui-même fournira la même interface."

#~ msgid "Testing JSON APIs"
#~ msgstr "Test des API JSON"

#~ msgid ""
#~ "Flask has great support for JSON, "
#~ "and is a popular choice for "
#~ "building JSON APIs. Making requests with"
#~ " JSON data and examining JSON data"
#~ " in responses is very convenient::"
#~ msgstr ""
#~ "Flask offre une excellente prise en "
#~ "charge de JSON et constitue un "
#~ "choix populaire pour la création d'API"
#~ " JSON. Faire des requêtes avec des"
#~ " données JSON et examiner les données"
#~ " JSON dans les réponses est très "
#~ "pratique :"

#~ msgid ""
#~ "Passing the ``json`` argument in the "
#~ "test client methods sets the request "
#~ "data to the JSON-serialized object "
#~ "and sets the content type to "
#~ "``application/json``. You can get the "
#~ "JSON data from the request or "
#~ "response with ``get_json``."
#~ msgstr ""
#~ "En passant l'argument ``json`` dans les"
#~ " méthodes du client de test, les "
#~ "données de la requête sont définies "
#~ "comme un objet sérialisé JSON et "
#~ "le type de contenu est défini "
#~ "comme ``application/json``. Vous pouvez "
#~ "récupérer les données JSON de la "
#~ "requête ou de la réponse avec "
#~ "``get_json``."

#~ msgid "Testing CLI Commands"
#~ msgstr "Test des commandes CLI"

#~ msgid ""
#~ "In the example above, invoking the "
#~ "command by name is useful because "
#~ "it verifies that the command was "
#~ "correctly registered with the app."
#~ msgstr ""
#~ "Dans l'exemple ci-dessus, invoquer la"
#~ " commande par son nom est utile "
#~ "car cela permet de vérifier que la"
#~ " commande a été correctement enregistrée"
#~ " dans l'application."

#~ msgid ""
#~ "If you want to test how your "
#~ "command parses parameters, without running "
#~ "the command, use its "
#~ ":meth:`~click.BaseCommand.make_context` method. This "
#~ "is useful for testing complex validation"
#~ " rules and custom types. ::"
#~ msgstr ""
#~ "Si vous voulez tester la façon "
#~ "dont votre commande analyse les "
#~ "paramètres, sans exécuter la commande, "
#~ "utilisez sa méthode "
#~ ":meth:`~click.BaseCommand.make_context`. Cette méthode "
#~ "est utile pour tester des règles "
#~ "de validation complexes et des types "
#~ "personnalisés. ::"

